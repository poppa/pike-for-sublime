//- This is a synatax file for Pike for the programming editor Sublime.
//-
//- NOTE! This JSON file has a special syntax that allows for comments like
//- this one.
//-
//- It also allows for multiline strings which JSON doesn't.
//- There are two ways to write multiline strings:
//- 
//- 1. A \ at the end of the line will concatenate the next line
//-    with the previous one.
//-
//-    { "key" : "This is a multi "        \
//-              "line string that spans " \
//-              "over three lines "       \
//-              "or more" }
//-
//-    The end result of this will be on one line.
//-
//- 2. A string like #"The string" can span over multiple lines without each
//-    line being ended or begun.
//-
//-    { "key" : #"This is a multi
//-               line string that spans
//-               over three lines
//-               or more" }
//-
//-    Whitespaces will be kept in the end result.

{ "name": "Pike",
  "scopeName" : "source.pike",
  "fileTypes" : ["pike", "pmod"],
  "firstLineMatch" : "(-[*]-( [Mm]ode:)? [Pp]ike -[*]-|^#!/.*\\bpike\\b)",
  "foldingStartMarker" : #"(?x)
     /\\*\\*(?!\\*)
    |^(?![^{]*?//|[^{]*?/\\*(?!.*?\\*/.*?\\{)).*?
    \\{\\s*($|//|/\\*(?!.*?\\*/.*\\S))",
  "foldingStopMarker" : "(?<!\\*)\\n\\*\\*/|^\\s*\\}",
  "keyEquivalent" : "^~C",
  "patterns" : [

    { "include" : "#preprocessor-rule-enabled" },
    { "include" : "#preprocessor-rule-disabled" },
    { "include" : "#preprocessor-rule-other" },
    { "include" : "#comments" },
    
    //- Control flow

    { "match" : "\\b(if|else|while|for|foreach|do|return|continue|break|" \
                "switch|case|default|goto|catch|lambda|gauge|inherit)\\b",
      "name" : "keyword.control.pike",
      "comment" : "Control flow keywords"
    },
    
    { "match" : "\\b(enum|float|int|typedef|void|object|class|mapping|string" \
                "|array|multiset|mixed|function)\\b",
      "name" : "storage.type.pike"
    },

    //- Modifiers

    { "match" : "\\b(public|protected|private|static|constant)\\b",
      "name" : "storage.modifier.pike",
      "comment" : "Modifiers"
    },

    { "include" : "#sizeof" },
    
    //- Numeric

    { "match" : "\\b((0(x|X)[0-9a-fA-F]*)|(([0-9]+\\.?[0-9]*)|(\\.[0-9]+))" \
                "((e|E)(\\+|-)?[0-9]+)?)\\b",
      "name" : "constant.numeric.pike",
      "comment" : "Numeric values"
    },

    //- Language constants

    { "match" : "\\b(UNDEFINED|__LINE__|__FILE__|true|false)\\b",
      "name"  : "constant.language.pike",
      "comment" : "Language constants"
    },

    //- Double quoted strings

    { "name" : "string.quoted.double.pike",
      "patterns" : [
        { "include" : "#string_escaped_char" },
        { "include" : "#string_placeholder" }
      ],
      "begin" : "\\\"",
      "beginCaptures" : {
        "0" : {
          "name" : "punctuation.definition.string.begin.pike"
        }
      },
      "end" : "(?:(?<=\\\\\\\\)|(?<!\\\\))\\\"",
      "endCaptures" : {
        "0" : {
          "name" : "punctuation.definition.string.end.pike"
        }
      }
    },

    //- Signle quoted strings

    { "name" : "string.quoted.single.pike",
      "patterns" : [
        { "include" : "#string_escaped_char" }
      ],
      "begin" : "'",
      "beginCaptures" : {
        "0" : {
          "name" : "punctuation.definition.string.begin.pike"
        }
      },
      "end" : "'",
      "endCaptures" : {
        "0" : {
          "name" : "punctuation.definition.string.end.pike"
        }
      }
    },

    //- Capture macros

    { "name" : "meta.preprocessor.macro.pike",
      "begin" : #"(?x)
                 ^\\s*\\#\\s*(define)\\s+           # define
                 ((?<id>[a-zA-Z_][a-zA-Z0-9_]*))    # macro name
                 (?:                                # and optionally:
                   (\\()                            # an open parenthesis
                     (
                       \\s* \\g<id> \\s*            # first argument
                       ((,) \\s* \\g<id> \\s*)*     # additional arguments
                       (?:\\.\\.\\.)?               # varargs ellipsis?
                     )
                   (\\))                             # a close parenthesis
                 )?",
      "beginCaptures" : {
        "1" : {
          "name" : "keyword.control.import.define.pike"
        },
        "2" : {
          "name" : "entity.name.function.preprocessor.pike"
        },
        "4" : {
          "name" : "punctuation.definition.parameters.pike"
        },
        "5" : {
          "name" : "variable.parameter.preprocessor.pike"
        },
        "7" : {
          "name" : "punctuation.separator.parameters.pike"
        },
        "8" : {
          "name" : "punctuation.definition.parameters.pike"
        }
      },
      "end" : "(?=(?://|/\\*))|$",
      "patterns" : [
        { "match" : "(?>\\\\\\s*\\n)",
          "name" : "punctuation.separator.continuation.pike"
        },
        { "include" : "$base" }
      ]
    },

    //- error, warning macro

    { "name" : "meta.preprocessor.diagnostic.pike",
      "begin" : "^\\s*#\\s*(error|warning)\\b",
      "captures" : {
        "1" : {
          "name" : "keyword.control.import.error.pike"
        }
      },
      "end" : "$",
      "patterns" : [
        { "match" : "(?>\\\\\\s*\\n)",
          "name" : "punctuation.separator.continuation.pike"
        }
      ]
    },

    //- include

    { "name" : "meta.preprocessor.pike.include",
      "begin" : "^\\s*#\\s*(include)\\b",
      "captures" : {
        "1" : {
          "name" : "keyword.control.import.include.pike"
        }
      },
      "end" : "(?=(?://|/\\*))|$",
      "patterns" : [
        { "match" : "(?>\\\\\\s*\\n)",
          "name" : "punctuation.separator.continuation.pike"
        },
        { "name" : "string.quoted.double.include.pike",
          "begin" : "\\\"",
          "beginCaptures" : {
            "0" : {
              "name" : "punctuation.definition.string.begin.pike"
            }
          },
          "end" : "\\\"",
          "endCaptures" : {
            "0" : {
              "name" : "punctuation.definition.string.end.pike"
            }
          }
        },
        { "name" : "string.quoted.other.lt-gt.include.pike",
          "begin" : "<",
          "beginCaptures" : {
            "0" : {
              "name" : "punctuation.definition.string.begin.pike"
            }
          },
          "end" : ">",
          "endCaptures" : {
            "0" : {
              "name" : "punctuation.definition.string.end.pike"
            }
          }
        }
      ]
    },

    { "begin" : "^\\s*#\\s*(define|defined|elif|else|if|ifdef|ifndef|" \
                "line|pragma|undef|endif|charset)\\b",
      "captures" :  {
        "1" : {
          "name" : "keyword.control.import.pike"
        }
      },
      "end" : "(?=(?://|/\\*))|$",
      "name" : "meta.preprocessor.pike",
      "patterns" : [
        { "match" : "(?>\\\\\\s*\\n)",
          "name" : "punctuation.separator.continuation.pike"
        }
      ]
    },

    { "include" : "#block" },

    //- Function declaration and body

    { "name" : "meta.function.pike",
      "begin" : #"(?x)
        (?:  ^                                 # begin-of-line
            |
             (?: (?= \\s )           (?<!else|return) (?<=\\w)    #  or word + space before name
               | (?= \\s*[A-Za-z_] ) (?<!&&)       (?<=[*&>])     #  or type modifier before name
             )
        )
        (\\s*) (?!(while|for|do|if|else|switch|catch|return|foreach|
                   object|int|float|function|mapping|array|multiset|
                   lambda|program|mixed|class)\\s*\\()
        (
          (?: [A-Za-z_`][A-Za-z0-9_]*+ | :: )++                    # actual name
        )
         \\s*(?=\\()",
      "beginCaptures" : {
        "1" : {
          "name" : "punctuation.whitespace.function.leading.pike"
        },
        "3" : {
          "name" : "entity.name.function.pike"
        },
        "4" : {
          "name" : "punctuation.definition.parameters.pike"
        }
      },
      "end" : "(?<=\\})|(?=#)|(;)",
      "patterns" : [
        { "include" : "#comments" },
        { "include" : "#parens" },
        { "match" : "\\bconstant\\b",
          "name" : "storage.modifier.pike"
        },
        { "include" : "#block" },
      ]
    },

    //- Includes

//-    { "include" : "#block" },
//-    { "include" : "#pragma.mark" },
//-    { "include" : "#builtinTypes" },
//-    { "include" : "#doubleQuotedStringLiteral" },
//-    { "include" : "#doubleQuotedString" },
//-    { "include" : "#singleQuotedString" }
  ],

  "repository" : {

    "comments" : {
      "patterns" : [
        { "captures" : {
            "0" : {
              "name" : "punctuation.definition.comment.$scopeName"
            }
          },
          "name" : "comment.block.$scopeName",
          "begin" : "/\\*",
          "end" : "\\*/"
        },

        { "captures" : {
            "1" : {
              "name" : "punctuation.definition.comment.$scopeName"
            }
          },
          "name" : "comment.line.double-slash.$scopeName",
          "match" : "(//).*$\\n?"
        }
      ]
    },

    "parens" : {
      "name" : "meta.parens.$scopeName",
      "begin" : "\\(",
      "end" : "\\)",
      "patterns" : [
        { "include" : "$base" }
      ]
    },

    "block" : {
      "name" : "meta.block.$scopeName",
      "begin" : "\\{",
      "end" : "\\}",
      "patterns" : [
        { "include" : "#block_innards" }
      ]
    },
    "block_innards" : {
      "patterns" : [
        {
          "name" : "meta.function-call.$scopeName",
          "match" : #"(?x)
                     (?: (?= \\s )  (?:(?<=else|new|return) | (?<!\\w)) (\\s+))?
                     (\\b
                      (?!(while|for|do|if|else|foreach|lambda|switch|
                          catch|enumerate|return|
                          mapping|multiset|mixed|int|float|class|function|
                          string|program|object)\\s*\\()
                        (?:(?!NS)[A-Za-z_][A-Za-z0-9_]*+\\b | :: )++    # actual name
                     )
                     \\s*(\\()",
          "captures" : {
            "1" : {
              "name" : "punctuation.whitespace.function-call.leading.$scopeName"
            },
            "2" : {
              "name" : "support.function.any-method.$scopeName"
            },
            "3" : {
              "name" : "punctuation.definition.parameters.$scopeName"
            }
          }
        },
        { "include" : "#block" },
        { "include" : "$base" }
      ]
    }
  },
  "uuid": "f0c5f4ad-3e8a-4add-9ebf-2ce1d5e5262f"
}