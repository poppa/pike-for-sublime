//- This is a synatax file for Pike for the programming editor Sublime.
//-
//- NOTE! This JSON file has a special syntax that allows for comments like
//- this one.

/*  Now there's support for ordinary multiline comments as well!
    if you ever feel like using them
*/

//- It also allows for multiline strings which JSON doesn't.
//- There are two ways to write multiline strings:
//-
//- 1. A \ at the end of the line will concatenate the next line
//-    with the previous one.
//-
//-    { "key" : "This is a multi "        \
//-              "line string that spans " \
//-              "over three lines "       \
//-              "or more" }
//-
//-    The end result of this will be on one line.
//-
//- 2. A string like #"The string" can span over multiple lines without each
//-    line being ended or begun.
//-
//-    { "key" : #"This is a multi
//-               line string that spans
//-               over three lines
//-               or more" }
//-
//-    Whitespaces will be kept in the end result.

{ "name": "Pike",
  "scopeName" : "source.pike",
  "fileTypes" : ["pike", "pmod"],
  "firstLineMatch" : "(-[*]-( [Mm]ode:)? [Pp]ike -[*]-|^#!/.*\\bpike\\b)",
  "foldingStartMarker" : #"(?x)
     /\\*\\*(?!\\*)
    |^(?![^{]*?//|[^{]*?/\\*(?!.*?\\*/.*?\\{)).*?
    \\{\\s*($|//|/\\*(?!.*?\\*/.*\\S))",
  "foldingStopMarker" : "(?<!\\*)\\n\\*\\*/|^\\s*\\}",
  "keyEquivalent" : "^~C",
  "patterns" : [

    { "include" : "#preprocessor-rule-enabled" },
    { "include" : "#preprocessor-rule-disabled" },
    { "include" : "#preprocessor-rule-other" },
    { "include" : "#comments" },

    //- Control flow

    { "match" : "\\b(if|else|while|for|foreach|do|return|continue|break|" \
                "switch|case|default|goto|catch|lambda|gauge|inherit)\\b",
      "name" : "keyword.control.pike",
      "comment" : "Control flow keywords"
    },

    { "match" : "\\b(enum|float|int|typedef|void|object|class|mapping|string" \
                "|array|multiset|mixed|function|program)\\b",
      "name" : "storage.type.pike"
    },

    //- Modifiers

    { "match" : "\\b(public|protected|private|static|constant|local|final)\\b",
      "name" : "storage.modifier.pike",
      "comment" : "Modifiers"
    },

    { "include" : "#sizeof" },

    //- Numeric

    { "match" : "(?:\\b|(?<!\\.)(?=\\.))" \
                "((0(x|X)[0-9a-fA-F]*)|(0(b|B)[01]+)|" \
                "(([0-9]+\\.?[0-9]*)|(\\.[0-9]+))((e|E)(\\+|-)?[0-9]+)?)\\b",
      "name" : "constant.numeric.pike",
      "comment" : "Numeric values"
    },

    //- Language constants

    { "match" : "\\b(UNDEFINED|__LINE__|__FILE__|__DIR__|" \
                "__VERSION__|__MAJOR__|__MINOR__|__BUILD__|" \
                "__REAL_VERSION__|__REAL_MAJOR__|__REAL_MINOR__|__REAL_BUILD__|" \
                "__DATE__|__TIME__|" \
                "__AUTO_BIGNUM__|__NT__|__PIKE__|__amigaos__|" \
                "true|false|this|this_program)\\b",
      "name"  : "constant.language.pike",
      "comment" : "Language constants"
    },

    //- Double quoted strings

    { "name" : "string.quoted.double.pike",
      "patterns" : [
        { "include" : "#string_escaped_char" },
        { "include" : "#string_placeholder" }
      ],
      "begin" : "\"",
      "beginCaptures" : {
        "0" : {
          "name" : "punctuation.definition.string.begin.pike"
        }
      },
      /* "end" : "(?:(?<=\\\\\\\\)|(?<!\\\\))\\\"", */
      "end" : "\"",
      "endCaptures" : {
        "0" : {
          "name" : "punctuation.definition.string.end.pike"
        }
      }
    },

    //- Signle quoted strings

    { "name" : "string.quoted.single.pike",
      "patterns" : [
        { "include" : "#string_escaped_char" }
      ],
      "begin" : "'",
      "beginCaptures" : {
        "0" : {
          "name" : "punctuation.definition.string.begin.pike"
        }
      },
      "end" : "'",
      "endCaptures" : {
        "0" : {
          "name" : "punctuation.definition.string.end.pike"
        }
      }
    },

    //- Capture macros

    { "name" : "meta.preprocessor.macro.pike",
      "begin" : #"(?x)
                 ^\\s*\\#\\s*(define)\\s+           # define
                 ((?<id>[a-zA-Z_][a-zA-Z0-9_]*))    # macro name
                 (?:                                # and optionally:
                   (\\()                            # an open parenthesis
                     (
                       \\s* \\g<id> \\s*            # first argument
                       ((,) \\s* \\g<id> \\s*)*     # additional arguments
                       (?:\\.\\.\\.)?               # varargs ellipsis?
                     )
                   (\\))                             # a close parenthesis
                 )?",
      "beginCaptures" : {
        "1" : { "name" : "keyword.control.import.define.pike" },
        "2" : { "name" : "entity.name.function.preprocessor.pike" },
        "4" : { "name" : "punctuation.definition.parameters.pike" },
        "5" : { "name" : "variable.parameter.preprocessor.pike" },
        "7" : { "name" : "punctuation.separator.parameters.pike" },
        "8" : { "name" : "punctuation.definition.parameters.pike" }
      },
      "end" : "(?=(?://|/\\*))|$",
      "patterns" : [
        { "match" : "(?>\\\\\\s*\\n)",
          "name" : "punctuation.separator.continuation.pike"
        },
        { "include" : "$base" }
      ]
    },

    //- error, warning macro

    { "name" : "meta.preprocessor.diagnostic.pike",
      "begin" : "^\\s*#\\s*(error|warning)\\b",
      "captures" : {
        "1" : { "name" : "keyword.control.import.error.pike" }
      },
      "end" : "$",
      "patterns" : [
        { "match" : "(?>\\\\\\s*\\n)",
          "name" : "punctuation.separator.continuation.pike"
        }
      ]
    },

    //- include

    { "name" : "meta.preprocessor.pike.include",
      "begin" : "^\\s*#\\s*(include|string)\\b",
      "captures" : {
        "1" : { "name" : "keyword.control.import.include.pike" }
      },
      "end" : "(?=(?://|/\\*))|$",
      "patterns" : [
        { "match" : "(?>\\\\\\s*\\n)",
          "name" : "punctuation.separator.continuation.pike"
        },
        { "name" : "string.quoted.double.include.pike",
          "begin" : "\\\"",
          "beginCaptures" : {
            "0" : { "name" : "punctuation.definition.string.begin.pike" }
          },
          "end" : "\\\"",
          "endCaptures" : {
            "0" : { "name" : "punctuation.definition.string.end.pike" }
          }
        },
        { "name" : "string.quoted.other.lt-gt.include.pike",
          "begin" : "<",
          "beginCaptures" : {
            "0" : { "name" : "punctuation.definition.string.begin.pike" }
          },
          "end" : ">",
          "endCaptures" : {
            "0" : { "name" : "punctuation.definition.string.end.pike" }
          }
        }
      ]
    },

    { "begin" : "^\\s*#\\s*(define|defined|elif|elseif|else|if|ifdef|ifndef|" \
                "(line|[0-9]+)|pragma|undef|undefine|endif|charset|pike|string)\\b",
      "captures" :  {
        "1" : { "name" : "keyword.control.import.pike" }
      },
      "end" : "(?=(?://|/\\*))|$",
      "name" : "meta.preprocessor.pike",
      "patterns" : [
        { "match" : "(?>\\\\\\s*\\n)",
          "name" : "punctuation.separator.continuation.pike"
        }
      ]
    },

    { "include" : "#block" },

    //- Function declaration and body

    { "name" : "meta.function.pike",
      "begin" : #"(?x)
        (?:  ^                                 # begin-of-line
            |
             (?: (?= \\s )           (?<!else|return) (?<=\\w)    #  or word + space before name
               | (?= \\s*[A-Za-z_.] ) (?<!&&)       (?<=[\\(\\)])     #  or type modifier before name
             )
        )
        (\\s*) (?!(while|for|do|if|else|switch|catch|return|foreach|
                   object|int|float|function|mapping|array|multiset|
                   lambda|program|mixed|class)\\s*\\()
        (
          (?: [[:alnum:]_`][[:alnum:]_]*+ | :: )++                    # actual name
        )
         \\s*(?=\\()",
      "beginCaptures" : {
        "1" : { "name" : "punctuation.whitespace.function.leading.pike" },
        "3" : { "name" : "entity.name.function.pike" },
        "4" : { "name" : "punctuation.definition.parameters.pike" }
      },
      "end" : "(?<=\\})|(?=#)|(;)",
      "patterns" : [
        { "include" : "#comments" },
        { "include" : "#parens" },
        { "match" : "\\bconstant\\b",
          "name" : "storage.modifier.pike"
        },
        { "include" : "#block" },
      ]
    },

    //- Includes

//-    { "include" : "#block" },
//-    { "include" : "#pragma.mark" },
//-    { "include" : "#builtinTypes" },
//-    { "include" : "#doubleQuotedStringLiteral" },
//-    { "include" : "#doubleQuotedString" },
//-    { "include" : "#singleQuotedString" }
  ],

  "repository" : {
    "comments" : {
      "patterns" : [
        { "captures" : {
            "0" : { "name" : "punctuation.definition.comment.$scopeName" }
          },
          "name" : "comment.block.$scopeName",
          "begin" : "/\\*",
          "end" : "\\*/"
        },

        { "captures" : {
            "1" : { "name" : "punctuation.definition.comment.$scopeName" }
          },
          "name" : "comment.line.double-slash.$scopeName",
          "match" : "(//).*$\\n?"
        }
      ]
    },

    "parens" : {
      "name" : "meta.parens.$scopeName",
      "begin" : "\\(",
      "end" : "\\)",
      "patterns" : [
        { "include" : "$base" }
      ]
    },

    "block" : {
      "name" : "meta.block.$scopeName",
      "begin" : "\\{",
      "end" : "\\}",
      "patterns" : [
        { "include" : "#block_innards" }
      ]
    },
    "block_innards" : {
      "patterns" : [
        {
          "name" : "meta.function-call.$scopeName",
          "match" : #"(?x)
                     (?: (?= \\s )  (?:(?<=else|new|return) | (?<!\\w)) (\\s+))?
                     (\\b
                      (?!(while|for|do|if|else|foreach|lambda|switch|
                          catch|enumerate|return|
                          mapping|multiset|mixed|int|float|class|function|array|
                          string|program|object)\\s*\\()
                        (?:(?!NS)[A-Za-z_][A-Za-z0-9_]*+\\b | :: )++    # actual name
                     )
                     \\s*(\\()",
          "captures" : {
            "1" : { "name" : "punctuation.whitespace.function-call.leading.$scopeName" },
            "2" : { "name" : "support.function.any-method.$scopeName" },
            "3" : { "name" : "punctuation.definition.parameters.$scopeName" }
          }
        },
        { "include" : "#block" },
        { "include" : "$base" }
      ]
    },

    "preprocessor-rule-enabled" : {
      "begin" : "^\\s*(#(if)\\s+(0*1)\\b)",
      "capture" : {
        "1" : { "name" : "meta.preprocessor.pike" },
        "2" : { "name" : "keyword.control.import.if.pike" },
        "3" : { "name" : "constant.numeric.preprocessor.pike" }
      },
      "end" : "^\\s*(#\\s*(endif)\\b)",
      "patterns" : [{
        "begin" : "^\\s*(#\\s*(else)\\b).*",
        "captures" : {
          "1" : { "name" : "meta.preprocessor.pike" },
          "2" : { "name" : "keyword.control.import.else.pike" }
        },
        "contentName" : "comment.block.preprocessor.else-branch",
        "end" : "(?=^\\s*#\\s*endif\\b.*$)",
        "patterns" : [
          { "include" : "#disabled" },
          { "include" : "#pragma-mark" }
        ]
      }, {
        "preprocessor-rule-enabled-block" : {
          "begin" : "^\\s*(#(if)\\s+(0*1)\\b)",
          "captures" : {
            "1" : { "name" : "meta.preprocessor.pike" },
            "2" : { "name" : "keyword.control.import.if.pike" },
            "3" : { "name" : "constant.numeric.preprocessor.pike" }
          },
          "end" : "^\\s*(#\\s*(endif)\\b)",
          "patterns" : [{
            "begin" : "^\\s*(#\\s*(else)\\b).*",
            "captures" : {
              "1" : { "name" : "meta.preprocessor.pike" },
              "2" : { "name" : "keyword.control.import.else.pike" }
            },
            "contentName" : "comment.block.preprocessor.else-branch.in-block",
            "end" : "(?=^\\s*#\\s*endif\\b.*$)",
            "patterns" : [
              { "include" : "#disabled" },
              { "include" : "#pragma-mark" }
            ]
          },{
            "begin" : "",
            "end" : "(?=^\\s*#\\s*(else|endif)\\b.*$)",
            "patterns" : [{
              "include" : "#block_innards"
            }]
          }]
        }
      }]
    },

    "preprocessor-rule-disabled" : {
      "begin":"^\\s*(#(if)\\s+(0)\\b).*",
      "captures": {
        "1": { "name":"meta.preprocessor.pike" },
        "2": { "name":"keyword.control.import.if.pike" },
        "3": { "name":"constant.numeric.preprocessor.pike" }
      },
      "end":"^\\s*(#\\s*(endif)\\b)",
      "patterns":[
        {
          "begin":"^\\s*(#\\s*(else)\\b)",
          "captures": {
            "1": { "name":"meta.preprocessor.pike" },
            "2": { "name":"keyword.control.import.else.pike" }
          },
          "end":"(?=^\\s*#\\s*endif\\b.*$)",
          "patterns":[
            { "include":"$base" }
          ]
        },{
          "begin":"",
          "end":"(?=^\\s*#\\s*(else|endif)\\b.*$)",
          "name":"comment.block.preprocessor.if-branch",
          "patterns":[
            { "include":"#disabled" },
            { "include":"#pragma-mark" }
          ]
        }
      ]
    },

    "preprocessor-rule-disabled-block" : {
      "begin":"^\\s*(#(if)\\s+(0)\\b).*",
      "captures": {
        "1": { "name":"meta.preprocessor.pike" },
        "2": { "name":"keyword.control.import.if.pike" },
        "3": { "name":"constant.numeric.preprocessor.pike" }
      },
      "end":"^\\s*(#\\s*(endif)\\b)",
      "patterns":[
        {
          "begin":"^\\s*(#\\s*(else)\\b)",
          "captures": {
            "1": { "name":"meta.preprocessor.c" },
            "2": { "name":"keyword.control.import.else.pike" }
          },
          "end":"(?=^\\s*#\\s*endif\\b.*$)",
          "patterns":[
            { "include":"#block_innards" }
          ]
        },{
          "begin":"",
          "end":"(?=^\\s*#\\s*(else|endif)\\b.*$)",
          "name":"comment.block.preprocessor.if-branch.in-block",
          "patterns":[
            { "include":"#disabled" },
            { "include":"#pragma-mark" }
          ]
        }
      ]
    },

    "pragma-mark" : {
      "name" : "meta.section",
      "captures" : {
        "1" : { "name" : "meta.preprocessor.pike" },
        "2" : { "name" : "keyword.control.import.pragma.pike" },
        "3" : { "name" : "meta.toc-list.pragma-mark.pike" }
      },
      "match" : "^\\s*(#\\s*(pragma\\s+mark)\\s+(.*))"
    },

    //- String escape i.e "My \"string\" with newline\n"
    //-                       ^       ^              ^^
    "string_escaped_char" : {
      "patterns" : [{
        "match" : "\\\\(\\\\|[0-3]\\d{,2}|[4-7]\\d?|" \
                  "x[a-fA-F0-9]{,2}|u[a-fA-F0-9]{,4}|U[a-fA-F0-9]{,8}|" \
                  "d[0-9]+|[[:alnum:]'\"?])",
        "name" : "constant.character.escape.pike"
      },
      { "match" : "\\\\.",
        "name" : "invalid.illegal.unknown-escape.pike"
      }]
    },

    //- String placeholder i.e sscanf (var, "%4d-%2d-%2d", int y, int m, int d)
    //-                                      ^^^ ^^^ ^^^
    "string_placeholder" : {
      "patterns" : [{
        "match" : #"(?x)%
                  (?!\\s|%)                            # Not followed by space or %
                  \\*?                                 # May be followed by a *
                  (\\d+\\$)?                           # field (argument #)
                  [*#0\\- +'\\[\\]]*                   # flags
                  [,;:_]?                              # separator character (AltiVec)
                  ((-?\\d+)|\\*(-?\\d+\\$)?)?          # minimum field width
                  (\\.((-?\\d+)|\\*(-?\\d+\\$)?)?)?    # precision
                  (hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)? # length modifier
                  [diouxXDOUeEfFgGaACcSspn%{}]         # conversion type",
        "name" : "constant.other.placeholder.pike"
      },
      { "match" : "%(?!\\s|%)(!<%)", /* Not followed by space or % and not preceded by % */
        "name" : "invalid.illegal.placeholder.pike"
      }]
    }
  },

  "uuid": "f0c5f4ad-3e8a-4add-9ebf-2ce1d5e5262f"
}